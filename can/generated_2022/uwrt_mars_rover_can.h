/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.4.0 Wed Mar  2 21:06:25 2022.
 */

#ifndef UWRT_MARS_ROVER_CAN_H
#define UWRT_MARS_ROVER_CAN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifndef EINVAL
#define EINVAL 22
#endif

/* Frame ids. */
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_FRAME_ID (0x01u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS0_FRAME_ID (0x02u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_FRAME_ID (0x03u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_FRAME_ID (0x04u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_FRAME_ID (0x05u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS0_FRAME_ID (0x06u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_FRAME_ID     \
  (0x07u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS0_FRAME_ID (0x09u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS0_FRAME_ID (0x0au)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_FRAME_ID (0x0bu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS0_FRAME_ID (0x0cu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS0_FRAME_ID (0x0du)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS0_FRAME_ID (0x0eu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS0_FRAME_ID (0x0fu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS0_FRAME_ID (0x10u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS0_FRAME_ID (0x11u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS0_FRAME_ID (0x12u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS0_FRAME_ID (0x13u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS0_FRAME_ID (0x14u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS0_FRAME_ID     \
  (0x15u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS0_FRAME_ID (0x16u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS0_FRAME_ID (0x17u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS0_FRAME_ID (0x18u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS0_FRAME_ID (0x19u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS0_FRAME_ID (0x1au)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS0_FRAME_ID (0x1bu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_FRAME_ID (0x21u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS1_FRAME_ID (0x22u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_FRAME_ID (0x23u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_FRAME_ID (0x24u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_FRAME_ID (0x25u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS1_FRAME_ID (0x26u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_FRAME_ID     \
  (0x27u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS1_FRAME_ID (0x29u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS1_FRAME_ID (0x2au)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_FRAME_ID (0x2bu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS1_FRAME_ID (0x2cu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS1_FRAME_ID (0x2du)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS1_FRAME_ID (0x2eu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS1_FRAME_ID (0x2fu)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS1_FRAME_ID (0x30u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS1_FRAME_ID (0x31u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS1_FRAME_ID (0x32u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS1_FRAME_ID (0x33u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS1_FRAME_ID (0x34u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS1_FRAME_ID     \
  (0x35u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS1_FRAME_ID (0x36u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS1_FRAME_ID (0x37u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS1_FRAME_ID (0x38u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS1_FRAME_ID (0x39u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS1_FRAME_ID (0x3au)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS1_FRAME_ID (0x3bu)

/* Frame lengths in bytes. */
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS0_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS0_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS0_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS0_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS0_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS0_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS1_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS1_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS1_LENGTH (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS1_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS1_LENGTH (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS1_LENGTH (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS1_LENGTH (8u)

/* Extended or standard frame types. */
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_IS_EXTENDED  \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS0_IS_EXTENDED  \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS0_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_ESTOP_MESSAGE_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_IS_EXTENDED  \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ESTIMATES_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_COUNT_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_POS_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_VEL_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_INPUT_TORQUE_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LIMITS_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_START_ANTICOGGING_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_VEL_LIMIT_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_ACCEL_LIMIT_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_TRAJ_INERTIA_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_IQ_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ESTIMATES_AXIS1_IS_EXTENDED  \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_REBOOT_ODRIVE_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_VBUS_VOLTAGE_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_CLEAR_ERRORS_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_LINEAR_COUNT_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_POSITION_GAIN_AXIS1_IS_EXTENDED (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_VEL_GAIN_AXIS1_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */

/* Signal choices. */
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_INVALID_STATE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_WATCHDOG_TIMER_EXPIRED_CHOICE \
  (2048u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_MIN_ENDSTOP_PRESSED_CHOICE \
  (4096u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_MAX_ENDSTOP_PRESSED_CHOICE \
  (8192u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_ESTOP_REQUESTED_CHOICE \
  (16384u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_HOMING_WITHOUT_ENDSTOP_CHOICE \
  (131072u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_OVER_TEMP_CHOICE \
  (262144u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_ERROR_ERROR_UNKNOWN_POSITION_CHOICE \
  (524288u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_UNDEFINED_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_IDLE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_STARTUP_SEQUENCE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_FULL_CALIBRATION_SEQUENCE_CHOICE \
  (3u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_MOTOR_CALIBRATION_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_INDEX_SEARCH_CHOICE \
  (6u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_OFFSET_CALIBRATION_CHOICE \
  (7u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_CLOSED_LOOP_CONTROL_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_LOCKIN_SPIN_CHOICE \
  (9u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_DIR_FIND_CHOICE \
  (10u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_HOMING_CHOICE \
  (11u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION_CHOICE \
  (12u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION_CHOICE \
  (13u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_VOLTAGE_CONTROL_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_TORQUE_CONTROL_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_VELOCITY_CONTROL_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS0_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_POSITION_CONTROL_CHOICE \
  (3u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_PHASE_RESISTANCE_OUT_OF_RANGE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_DRV_FAULT_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CONTROL_DEADLINE_MISSED_CHOICE \
  (16u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_MODULATION_MAGNITUDE_CHOICE \
  (128u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_SENSE_SATURATION_CHOICE \
  (1024u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_LIMIT_VIOLATION_CHOICE \
  (4096u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_MODULATION_IS_NAN_CHOICE \
  (65536u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_MOTOR_THERMISTOR_OVER_TEMP_CHOICE \
  (131072u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_FET_THERMISTOR_OVER_TEMP_CHOICE \
  (262144u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_TIMER_UPDATE_MISSED_CHOICE \
  (524288u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_MEASUREMENT_UNAVAILABLE_CHOICE \
  (1048576u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CONTROLLER_FAILED_CHOICE \
  (2097152u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_I_BUS_OUT_OF_RANGE_CHOICE \
  (4194304u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_BRAKE_RESISTOR_DISARMED_CHOICE \
  (8388608u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_SYSTEM_LEVEL_CHOICE \
  (16777216u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_BAD_TIMING_CHOICE \
  (33554432u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_PHASE_ESTIMATE_CHOICE \
  (67108864u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_PHASE_VEL_CHOICE \
  (134217728u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_TORQUE_CHOICE \
  (268435456u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_CURRENT_COMMAND_CHOICE \
  (536870912u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_CURRENT_MEASUREMENT_CHOICE \
  (1073741824u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_VBUS_VOLTAGE_CHOICE \
  (2147483648u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_VOLTAGE_COMMAND_CHOICE \
  (4294967296u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_GAINS_CHOICE \
  (8589934592u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_CONTROLLER_INITIALIZING_CHOICE \
  (17179869184u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS0_ODRIVE_MOTOR_ERROR_ERROR_UNBALANCED_PHASES_CHOICE \
  (34359738368u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_UNSTABLE_GAIN_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_CPR_POLEPAIRS_MISMATCH_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_NO_RESPONSE_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_UNSUPPORTED_ENCODER_MODE_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_ILLEGAL_HALL_STATE_CHOICE \
  (16u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_INDEX_NOT_FOUND_YET_CHOICE \
  (32u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_TIMEOUT_CHOICE \
  (64u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_COM_FAIL_CHOICE \
  (128u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_NOT_READY_CHOICE \
  (256u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS0_ODRIVE_ENCODER_ERROR_ERROR_HALL_NOT_CALIBRATED_YET_CHOICE \
  (512u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_ODRIVE_SENSORLESS_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_ODRIVE_SENSORLESS_ERROR_ERROR_UNSTABLE_GAIN_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS0_ODRIVE_SENSORLESS_ERROR_ERROR_UNKNOWN_CURRENT_MEASUREMENT_CHOICE \
  (2u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS0_ODRIVE_AXIS_CAN_NODE_ID_ERROR_NONE_CHOICE \
  (0u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_UNDEFINED_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_IDLE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_STARTUP_SEQUENCE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_FULL_CALIBRATION_SEQUENCE_CHOICE \
  (3u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_MOTOR_CALIBRATION_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_INDEX_SEARCH_CHOICE \
  (6u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_OFFSET_CALIBRATION_CHOICE \
  (7u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_CLOSED_LOOP_CONTROL_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_LOCKIN_SPIN_CHOICE \
  (9u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_DIR_FIND_CHOICE \
  (10u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_HOMING_CHOICE \
  (11u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION_CHOICE \
  (12u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS0_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION_CHOICE \
  (13u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_CONTROL_MODE_CONTROL_MODE_VOLTAGE_CONTROL_CHOICE \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_CONTROL_MODE_CONTROL_MODE_TORQUE_CONTROL_CHOICE \
  (1)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_CONTROL_MODE_CONTROL_MODE_VELOCITY_CONTROL_CHOICE \
  (2)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_CONTROL_MODE_CONTROL_MODE_POSITION_CONTROL_CHOICE \
  (3)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_INACTIVE_CHOICE \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_PASSTHROUGH_CHOICE \
  (1)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_VEL_RAMP_CHOICE \
  (2)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_POS_FILTER_CHOICE \
  (3)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_MIX_CHANNELS_CHOICE \
  (4)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_TRAP_TRAJ_CHOICE \
  (5)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_TORQUE_RAMP_CHOICE \
  (6)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_MIRROR_CHOICE \
  (7)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS0_ODRIVE_INPUT_MODE_INPUT_MODE_TUNING_CHOICE \
  (8)

#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_INVALID_STATE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_WATCHDOG_TIMER_EXPIRED_CHOICE \
  (2048u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_MIN_ENDSTOP_PRESSED_CHOICE \
  (4096u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_MAX_ENDSTOP_PRESSED_CHOICE \
  (8192u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_ESTOP_REQUESTED_CHOICE \
  (16384u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_HOMING_WITHOUT_ENDSTOP_CHOICE \
  (131072u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_OVER_TEMP_CHOICE \
  (262144u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_ERROR_ERROR_UNKNOWN_POSITION_CHOICE \
  (524288u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_UNDEFINED_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_IDLE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_STARTUP_SEQUENCE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_FULL_CALIBRATION_SEQUENCE_CHOICE \
  (3u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_MOTOR_CALIBRATION_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_INDEX_SEARCH_CHOICE \
  (6u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_OFFSET_CALIBRATION_CHOICE \
  (7u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_CLOSED_LOOP_CONTROL_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_LOCKIN_SPIN_CHOICE \
  (9u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_DIR_FIND_CHOICE \
  (10u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_HOMING_CHOICE \
  (11u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION_CHOICE \
  (12u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_AXIS_CURRENT_STATE_AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION_CHOICE \
  (13u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_VOLTAGE_CONTROL_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_TORQUE_CONTROL_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_VELOCITY_CONTROL_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_HEARTBEAT_MESSAGE_AXIS1_ODRIVE_CONTROLLER_STATUS_CONTROL_MODE_POSITION_CONTROL_CHOICE \
  (3u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_PHASE_RESISTANCE_OUT_OF_RANGE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_DRV_FAULT_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CONTROL_DEADLINE_MISSED_CHOICE \
  (16u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_MODULATION_MAGNITUDE_CHOICE \
  (128u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_SENSE_SATURATION_CHOICE \
  (1024u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_LIMIT_VIOLATION_CHOICE \
  (4096u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_MODULATION_IS_NAN_CHOICE \
  (65536u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_MOTOR_THERMISTOR_OVER_TEMP_CHOICE \
  (131072u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_FET_THERMISTOR_OVER_TEMP_CHOICE \
  (262144u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_TIMER_UPDATE_MISSED_CHOICE \
  (524288u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CURRENT_MEASUREMENT_UNAVAILABLE_CHOICE \
  (1048576u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CONTROLLER_FAILED_CHOICE \
  (2097152u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_I_BUS_OUT_OF_RANGE_CHOICE \
  (4194304u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_BRAKE_RESISTOR_DISARMED_CHOICE \
  (8388608u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_SYSTEM_LEVEL_CHOICE \
  (16777216u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_BAD_TIMING_CHOICE \
  (33554432u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_PHASE_ESTIMATE_CHOICE \
  (67108864u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_PHASE_VEL_CHOICE \
  (134217728u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_TORQUE_CHOICE \
  (268435456u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_CURRENT_COMMAND_CHOICE \
  (536870912u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_CURRENT_MEASUREMENT_CHOICE \
  (1073741824u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_VBUS_VOLTAGE_CHOICE \
  (2147483648u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_VOLTAGE_COMMAND_CHOICE \
  (4294967296u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNKNOWN_GAINS_CHOICE \
  (8589934592u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_CONTROLLER_INITIALIZING_CHOICE \
  (17179869184u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_MOTOR_ERROR_AXIS1_ODRIVE_MOTOR_ERROR_ERROR_UNBALANCED_PHASES_CHOICE \
  (34359738368u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_UNSTABLE_GAIN_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_CPR_POLEPAIRS_MISMATCH_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_NO_RESPONSE_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_UNSUPPORTED_ENCODER_MODE_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_ILLEGAL_HALL_STATE_CHOICE \
  (16u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_INDEX_NOT_FOUND_YET_CHOICE \
  (32u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_TIMEOUT_CHOICE \
  (64u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_COM_FAIL_CHOICE \
  (128u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_ABS_SPI_NOT_READY_CHOICE \
  (256u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_ENCODER_ERROR_AXIS1_ODRIVE_ENCODER_ERROR_ERROR_HALL_NOT_CALIBRATED_YET_CHOICE \
  (512u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_ODRIVE_SENSORLESS_ERROR_ERROR_NONE_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_ODRIVE_SENSORLESS_ERROR_ERROR_UNSTABLE_GAIN_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_GET_SENSORLESS_ERROR_AXIS1_ODRIVE_SENSORLESS_ERROR_ERROR_UNKNOWN_CURRENT_MEASUREMENT_CHOICE \
  (2u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_NODE_ID_AXIS1_ODRIVE_AXIS_CAN_NODE_ID_ERROR_NONE_CHOICE \
  (0u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_UNDEFINED_CHOICE \
  (0u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_IDLE_CHOICE \
  (1u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_STARTUP_SEQUENCE_CHOICE \
  (2u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_FULL_CALIBRATION_SEQUENCE_CHOICE \
  (3u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_MOTOR_CALIBRATION_CHOICE \
  (4u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_INDEX_SEARCH_CHOICE \
  (6u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_OFFSET_CALIBRATION_CHOICE \
  (7u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_CLOSED_LOOP_CONTROL_CHOICE \
  (8u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_LOCKIN_SPIN_CHOICE \
  (9u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_DIR_FIND_CHOICE \
  (10u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_HOMING_CHOICE \
  (11u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION_CHOICE \
  (12u)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_AXIS_REQUESTED_STATE_AXIS1_ODRIVE_AXIS_REQUESTED_STATE_AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION_CHOICE \
  (13u)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_CONTROL_MODE_CONTROL_MODE_VOLTAGE_CONTROL_CHOICE \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_CONTROL_MODE_CONTROL_MODE_TORQUE_CONTROL_CHOICE \
  (1)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_CONTROL_MODE_CONTROL_MODE_VELOCITY_CONTROL_CHOICE \
  (2)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_CONTROL_MODE_CONTROL_MODE_POSITION_CONTROL_CHOICE \
  (3)

#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_INACTIVE_CHOICE \
  (0)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_PASSTHROUGH_CHOICE \
  (1)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_VEL_RAMP_CHOICE \
  (2)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_POS_FILTER_CHOICE \
  (3)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_MIX_CHANNELS_CHOICE \
  (4)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_TRAP_TRAJ_CHOICE \
  (5)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_TORQUE_RAMP_CHOICE \
  (6)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_MIRROR_CHOICE \
  (7)
#define UWRT_MARS_ROVER_CAN_ODRIVE_SET_CONTROLLER_MODES_AXIS1_ODRIVE_INPUT_MODE_INPUT_MODE_TUNING_CHOICE \
  (8)

/**
 * Signals in message ODRIVE_heartbeatMessage_axis0.
 *
 * Heartbeat messages for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_heartbeat_message_axis0_t {
  /**
   * Odrive axis errors
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_error;

  /**
   * Odrive axis current state
   *
   * Range: 0..254 (0.0..254.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint8_t odrive_axis_current_state;

  /**
   * Odrive controller status
   *
   * Range: 0..254 (0.0..254.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint8_t odrive_controller_status;
};

/**
 * Signals in message ODRIVE_EstopMessage_axis0.
 *
 * Odrive Estop message
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_estop_message_axis0_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_getMotorError_axis0.
 *
 * Heartbeat messages for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_motor_error_axis0_t {
  /**
   * Odrive motor errors
   *
   * Range: 0..18446744073709552000 (0.0..1.8446744073709552E+19 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint64_t odrive_motor_error;
};

/**
 * Signals in message ODRIVE_getEncoderError_axis0.
 *
 * Encoder error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_error_axis0_t {
  /**
   * Odrive encoder error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_error;
};

/**
 * Signals in message ODRIVE_getSensorlessError_axis0.
 *
 * Sesnorless error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_t {
  /**
   * Odrive sesnsorless error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_error;
};

/**
 * Signals in message ODRIVE_setAxisNodeID_axis0.
 *
 * Sesnorless error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_t {
  /**
   * Odrive Axis CAN Node ID error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_can_node_id;
};

/**
 * Signals in message ODRIVE_setAxisRequestedState_axis0.
 *
 * Set axis requested state
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_t {
  /**
   * Odrive axis requested state
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_requested_state;
};

/**
 * Signals in message ODRIVE_getEncoderEstimates_axis0.
 *
 * Get encoder estimates
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_t {
  /**
   * Odrive encoder position estimate
   *
   * Range: 0..1 (0.0..1.0 turns)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_pos_estimate;

  /**
   * Odrive encoder velocity estimate
   *
   * Range: 0..1 (0.0..1.0 turns/s)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_vel_estimate;
};

/**
 * Signals in message ODRIVE_getEncoderCount_axis0.
 *
 * Get encoder count
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_count_axis0_t {
  /**
   * Odrive encoder shadow count
   *
   * Range: 0..1 (0.0..1.0 counts)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_encoder_shadow_count;

  /**
   * Odrive encoder count in CPR
   *
   * Range: 0..1 (0.0..1.0 counts)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_encoder_countin_cpr;
};

/**
 * Signals in message ODRIVE_setControllerModes_axis0.
 *
 * Set controller modes
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_controller_modes_axis0_t {
  /**
   * Odrive control mode
   *
   * Range: -2147483647..2147483647 (-2147483647.0..2147483647.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_control_mode;

  /**
   * Odrive input mode
   *
   * Range: -2147483647..2147483647 (-2147483647.0..2147483647.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_input_mode;
};

/**
 * Signals in message ODRIVE_SetInputPos_axis0.
 *
 * Set input position
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_pos_axis0_t {
  /**
   * Odrive input position
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_pos;

  /**
   * Odrive velocity feed forward
   *
   * Range: 0..1000 (0.0..1.0 -)
   * Scale: 0.001
   * Offset: 0.0
   */
  int16_t odrive_vel_ff;

  /**
   * Odrive torque feed forward
   *
   * Range: 0..1000 (0.0..1.0 -)
   * Scale: 0.001
   * Offset: 0.0
   */
  int16_t odrive_torque_ff;
};

/**
 * Signals in message ODRIVE_setInputVel_axis0.
 *
 * Set input velocity
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_vel_axis0_t {
  /**
   * Odrive input velocity
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_vel;

  /**
   * Odrive torque feed forward
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_torque_ff;
};

/**
 * Signals in message ODRIVE_setInputTorque_axis0.
 *
 * Set input torque
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_torque_axis0_t {
  /**
   * Odrive input torque
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_torque;
};

/**
 * Signals in message ODRIVE_setLimits_axis0.
 *
 * Set limits
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_limits_axis0_t {
  /**
   * Odrive velocity limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_velocity_limit;

  /**
   * Odrive current limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_current_limit;
};

/**
 * Signals in message ODRIVE_StartAnticogging_axis0.
 *
 * Start anticogging
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_start_anticogging_axis0_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_setTrajVelLimit_axis0.
 *
 * Set traj velocity limit
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_t {
  /**
   * Odrive traj velocity limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_vel_limit;
};

/**
 * Signals in message ODRIVE_setTrajAccelLimit_axis0.
 *
 * Set traj accleration limit
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_t {
  /**
   * Odrive traj acceleration limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_accel_limit;

  /**
   * Odrive traj deceleration limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_decel_limit;
};

/**
 * Signals in message ODRIVE_setTrajInertia_axis0.
 *
 * Set traj inertia
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_t {
  /**
   * Odrive traj inertia
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_inertia;
};

/**
 * Signals in message ODRIVE_getIQ_axis0.
 *
 * get IQ
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_iq_axis0_t {
  /**
   * Odrive IQ setpoint
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_iq_setpoint;

  /**
   * Odrive IQ measured
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_iq_measured;
};

/**
 * Signals in message ODRIVE_GetSensorlessEstimates_axis0.
 *
 * get sensorless estimates
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_t {
  /**
   * Odrive sensorless position estimate
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_pos_estimate;

  /**
   * Odrive sensorless velocity estimate
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_vel_estimate;
};

/**
 * Signals in message ODRIVE_RebootOdrive_axis0.
 *
 * reboot Odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_reboot_odrive_axis0_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_getVbusVoltage_axis0.
 *
 * get vbus voltage
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_t {
  /**
   * Odrive vbus voltage
   *
   * Range: 0..1 (0.0..1.0 V)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vbus_voltage;
};

/**
 * Signals in message ODRIVE_ClearErrors_axis0.
 *
 * clear error
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_clear_errors_axis0_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_setLinearCount_axis0.
 *
 * set linear count
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_linear_count_axis0_t {
  /**
   * Odrive position
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_position;
};

/**
 * Signals in message ODRIVE_setPositionGain_axis0.
 *
 * set position gain
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_position_gain_axis0_t {
  /**
   * Odrive position gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_pos_gain;
};

/**
 * Signals in message ODRIVE_setVelGain_axis0.
 *
 * set velocity gain
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_vel_gain_axis0_t {
  /**
   * Odrive velocity gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vel_gain;

  /**
   * Odrive velocity integrator gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vel_integrator_gain;
};

/**
 * Signals in message ODRIVE_heartbeatMessage_axis1.
 *
 * Heartbeat messages for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_heartbeat_message_axis1_t {
  /**
   * Odrive axis errors
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_error;

  /**
   * Odrive axis current state
   *
   * Range: 0..254 (0.0..254.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint8_t odrive_axis_current_state;

  /**
   * Odrive controller status
   *
   * Range: 0..254 (0.0..254.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint8_t odrive_controller_status;
};

/**
 * Signals in message ODRIVE_EstopMessage_axis1.
 *
 * Odrive Estop message
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_estop_message_axis1_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_getMotorError_axis1.
 *
 * Heartbeat messages for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_motor_error_axis1_t {
  /**
   * Odrive motor errors
   *
   * Range: 0..18446744073709552000 (0.0..1.8446744073709552E+19 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint64_t odrive_motor_error;
};

/**
 * Signals in message ODRIVE_getEncoderError_axis1.
 *
 * Encoder error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_error_axis1_t {
  /**
   * Odrive encoder error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_error;
};

/**
 * Signals in message ODRIVE_getSensorlessError_axis1.
 *
 * Sesnorless error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_t {
  /**
   * Odrive sesnsorless error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_error;
};

/**
 * Signals in message ODRIVE_setAxisNodeID_axis1.
 *
 * Sesnorless error for odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_t {
  /**
   * Odrive Axis CAN Node ID error
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_can_node_id;
};

/**
 * Signals in message ODRIVE_setAxisRequestedState_axis1.
 *
 * Set axis requested state
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_t {
  /**
   * Odrive axis requested state
   *
   * Range: 0..4294967294 (0.0..4294967294.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_axis_requested_state;
};

/**
 * Signals in message ODRIVE_getEncoderEstimates_axis1.
 *
 * Get encoder estimates
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_t {
  /**
   * Odrive encoder position estimate
   *
   * Range: 0..1 (0.0..1.0 turns)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_pos_estimate;

  /**
   * Odrive encoder velocity estimate
   *
   * Range: 0..1 (0.0..1.0 turns/s)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_encoder_vel_estimate;
};

/**
 * Signals in message ODRIVE_getEncoderCount_axis1.
 *
 * Get encoder count
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_encoder_count_axis1_t {
  /**
   * Odrive encoder shadow count
   *
   * Range: 0..1 (0.0..1.0 counts)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_encoder_shadow_count;

  /**
   * Odrive encoder count in CPR
   *
   * Range: 0..1 (0.0..1.0 counts)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_encoder_countin_cpr;
};

/**
 * Signals in message ODRIVE_setControllerModes_axis1.
 *
 * Set controller modes
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_controller_modes_axis1_t {
  /**
   * Odrive control mode
   *
   * Range: -2147483647..2147483647 (-2147483647.0..2147483647.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_control_mode;

  /**
   * Odrive input mode
   *
   * Range: -2147483647..2147483647 (-2147483647.0..2147483647.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_input_mode;
};

/**
 * Signals in message ODRIVE_SetInputPos_axis1.
 *
 * Set input position
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_pos_axis1_t {
  /**
   * Odrive input position
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_pos;

  /**
   * Odrive velocity feed forward
   *
   * Range: 0..1000 (0.0..1.0 -)
   * Scale: 0.001
   * Offset: 0.0
   */
  int16_t odrive_vel_ff;

  /**
   * Odrive torque feed forward
   *
   * Range: 0..1000 (0.0..1.0 -)
   * Scale: 0.001
   * Offset: 0.0
   */
  int16_t odrive_torque_ff;
};

/**
 * Signals in message ODRIVE_setInputVel_axis1.
 *
 * Set input velocity
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_vel_axis1_t {
  /**
   * Odrive input velocity
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_vel;

  /**
   * Odrive torque feed forward
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_torque_ff;
};

/**
 * Signals in message ODRIVE_setInputTorque_axis1.
 *
 * Set input torque
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_input_torque_axis1_t {
  /**
   * Odrive input torque
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_input_torque;
};

/**
 * Signals in message ODRIVE_setLimits_axis1.
 *
 * Set limits
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_limits_axis1_t {
  /**
   * Odrive velocity limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_velocity_limit;

  /**
   * Odrive current limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_current_limit;
};

/**
 * Signals in message ODRIVE_StartAnticogging_axis1.
 *
 * Start anticogging
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_start_anticogging_axis1_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_setTrajVelLimit_axis1.
 *
 * Set traj velocity limit
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_t {
  /**
   * Odrive traj velocity limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_vel_limit;
};

/**
 * Signals in message ODRIVE_setTrajAccelLimit_axis1.
 *
 * Set traj accleration limit
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_t {
  /**
   * Odrive traj acceleration limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_accel_limit;

  /**
   * Odrive traj deceleration limit
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_decel_limit;
};

/**
 * Signals in message ODRIVE_setTrajInertia_axis1.
 *
 * Set traj inertia
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_t {
  /**
   * Odrive traj inertia
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_traj_inertia;
};

/**
 * Signals in message ODRIVE_getIQ_axis1.
 *
 * get IQ
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_iq_axis1_t {
  /**
   * Odrive IQ setpoint
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_iq_setpoint;

  /**
   * Odrive IQ measured
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_iq_measured;
};

/**
 * Signals in message ODRIVE_GetSensorlessEstimates_axis1.
 *
 * get sensorless estimates
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_t {
  /**
   * Odrive sensorless position estimate
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_pos_estimate;

  /**
   * Odrive sensorless velocity estimate
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_sensorless_vel_estimate;
};

/**
 * Signals in message ODRIVE_RebootOdrive_axis1.
 *
 * reboot Odrive
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_reboot_odrive_axis1_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_getVbusVoltage_axis1.
 *
 * get vbus voltage
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_t {
  /**
   * Odrive vbus voltage
   *
   * Range: 0..1 (0.0..1.0 V)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vbus_voltage;
};

/**
 * Signals in message ODRIVE_ClearErrors_axis1.
 *
 * clear error
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_clear_errors_axis1_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ODRIVE_setLinearCount_axis1.
 *
 * set linear count
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_linear_count_axis1_t {
  /**
   * Odrive position
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  int32_t odrive_position;
};

/**
 * Signals in message ODRIVE_setPositionGain_axis1.
 *
 * set position gain
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_position_gain_axis1_t {
  /**
   * Odrive position gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_pos_gain;
};

/**
 * Signals in message ODRIVE_setVelGain_axis1.
 *
 * set velocity gain
 *
 * All signal values are as on the CAN bus.
 */
struct uwrt_mars_rover_can_odrive_set_vel_gain_axis1_t {
  /**
   * Odrive velocity gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vel_gain;

  /**
   * Odrive velocity integrator gain
   *
   * Range: 0..1 (0.0..1.0 -)
   * Scale: 1.0
   * Offset: 0.0
   */
  uint32_t odrive_vel_integrator_gain;
};

/**
 * Pack message ODRIVE_heartbeatMessage_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_heartbeat_message_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_heartbeat_message_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_heartbeatMessage_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_heartbeat_message_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_heartbeat_message_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_error_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_current_state_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_current_state_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_axis_current_state_is_in_range(
    uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_controller_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_controller_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis0_odrive_controller_status_is_in_range(
    uint8_t value);

/**
 * Pack message ODRIVE_EstopMessage_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_estop_message_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_estop_message_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_EstopMessage_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_estop_message_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_estop_message_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_getMotorError_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_motor_error_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_motor_error_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getMotorError_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_motor_error_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_motor_error_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t
uwrt_mars_rover_can_odrive_get_motor_error_axis0_odrive_motor_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_motor_error_axis0_odrive_motor_error_decode(
    uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_motor_error_axis0_odrive_motor_error_is_in_range(
    uint64_t value);

/**
 * Pack message ODRIVE_getEncoderError_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_error_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_error_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderError_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_error_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_error_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_error_axis0_odrive_encoder_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_error_axis0_odrive_encoder_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_error_axis0_odrive_encoder_error_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getSensorlessError_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getSensorlessError_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_odrive_sensorless_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_odrive_sensorless_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_error_axis0_odrive_sensorless_error_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setAxisNodeID_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setAxisNodeID_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_odrive_axis_can_node_id_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_odrive_axis_can_node_id_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_axis_node_id_axis0_odrive_axis_can_node_id_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setAxisRequestedState_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setAxisRequestedState_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_odrive_axis_requested_state_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_odrive_axis_requested_state_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_axis_requested_state_axis0_odrive_axis_requested_state_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getEncoderEstimates_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderEstimates_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_pos_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_pos_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_pos_estimate_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_vel_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_vel_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_estimates_axis0_odrive_encoder_vel_estimate_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getEncoderCount_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_count_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_count_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderCount_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_count_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_count_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_shadow_count_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_shadow_count_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_shadow_count_is_in_range(
    int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_countin_cpr_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_countin_cpr_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_count_axis0_odrive_encoder_countin_cpr_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_setControllerModes_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_controller_modes_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_controller_modes_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setControllerModes_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_controller_modes_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_controller_modes_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_control_mode_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_control_mode_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_control_mode_is_in_range(
    int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_input_mode_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_input_mode_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_controller_modes_axis0_odrive_input_mode_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_SetInputPos_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_pos_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_pos_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_SetInputPos_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_pos_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_pos_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_input_pos_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_input_pos_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_input_pos_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_vel_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_vel_ff_decode(
    int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_vel_ff_is_in_range(
    int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_torque_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_torque_ff_decode(
    int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis0_odrive_torque_ff_is_in_range(
    int16_t value);

/**
 * Pack message ODRIVE_setInputVel_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_vel_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_vel_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setInputVel_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_vel_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_vel_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_input_vel_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_input_vel_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_input_vel_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_torque_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_torque_ff_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_vel_axis0_odrive_torque_ff_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setInputTorque_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_torque_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_torque_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setInputTorque_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_torque_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_torque_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_input_torque_axis0_odrive_input_torque_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_input_torque_axis0_odrive_input_torque_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_torque_axis0_odrive_input_torque_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setLimits_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_limits_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_limits_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setLimits_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_limits_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_limits_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_velocity_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_velocity_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_velocity_limit_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_current_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_current_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_limits_axis0_odrive_current_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_StartAnticogging_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_start_anticogging_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_start_anticogging_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_StartAnticogging_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_start_anticogging_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_start_anticogging_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_setTrajVelLimit_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajVelLimit_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_odrive_traj_vel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_odrive_traj_vel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis0_odrive_traj_vel_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setTrajAccelLimit_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajAccelLimit_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_accel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_accel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_accel_limit_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_decel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_decel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis0_odrive_traj_decel_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setTrajInertia_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajInertia_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_odrive_traj_inertia_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_odrive_traj_inertia_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_inertia_axis0_odrive_traj_inertia_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getIQ_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_iq_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_iq_axis0_t *src_p, size_t size);

/**
 * Unpack message ODRIVE_getIQ_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_iq_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_iq_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_setpoint_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_setpoint_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_measured_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_iq_axis0_odrive_iq_measured_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_GetSensorlessEstimates_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_GetSensorlessEstimates_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_pos_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_pos_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_pos_estimate_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_vel_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_vel_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis0_odrive_sensorless_vel_estimate_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_RebootOdrive_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_reboot_odrive_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_reboot_odrive_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_RebootOdrive_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_reboot_odrive_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_reboot_odrive_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_getVbusVoltage_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getVbusVoltage_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_odrive_vbus_voltage_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_odrive_vbus_voltage_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_vbus_voltage_axis0_odrive_vbus_voltage_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_ClearErrors_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_clear_errors_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_clear_errors_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_ClearErrors_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_clear_errors_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_clear_errors_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_setLinearCount_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_linear_count_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_linear_count_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setLinearCount_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_linear_count_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_linear_count_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_linear_count_axis0_odrive_position_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_linear_count_axis0_odrive_position_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_linear_count_axis0_odrive_position_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_setPositionGain_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_position_gain_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_position_gain_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setPositionGain_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_position_gain_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_position_gain_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_position_gain_axis0_odrive_pos_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_position_gain_axis0_odrive_pos_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_position_gain_axis0_odrive_pos_gain_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setVelGain_axis0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_vel_gain_axis0_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_vel_gain_axis0_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setVelGain_axis0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_vel_gain_axis0_unpack(
    struct uwrt_mars_rover_can_odrive_set_vel_gain_axis0_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_gain_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_integrator_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_integrator_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_vel_gain_axis0_odrive_vel_integrator_gain_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_heartbeatMessage_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_heartbeat_message_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_heartbeat_message_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_heartbeatMessage_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_heartbeat_message_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_heartbeat_message_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_error_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_current_state_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_current_state_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_axis_current_state_is_in_range(
    uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_controller_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_controller_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_heartbeat_message_axis1_odrive_controller_status_is_in_range(
    uint8_t value);

/**
 * Pack message ODRIVE_EstopMessage_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_estop_message_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_estop_message_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_EstopMessage_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_estop_message_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_estop_message_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_getMotorError_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_motor_error_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_motor_error_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getMotorError_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_motor_error_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_motor_error_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t
uwrt_mars_rover_can_odrive_get_motor_error_axis1_odrive_motor_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_motor_error_axis1_odrive_motor_error_decode(
    uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_motor_error_axis1_odrive_motor_error_is_in_range(
    uint64_t value);

/**
 * Pack message ODRIVE_getEncoderError_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_error_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_error_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderError_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_error_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_error_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_error_axis1_odrive_encoder_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_error_axis1_odrive_encoder_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_error_axis1_odrive_encoder_error_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getSensorlessError_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getSensorlessError_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_odrive_sensorless_error_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_odrive_sensorless_error_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_error_axis1_odrive_sensorless_error_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setAxisNodeID_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setAxisNodeID_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_odrive_axis_can_node_id_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_odrive_axis_can_node_id_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_axis_node_id_axis1_odrive_axis_can_node_id_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setAxisRequestedState_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setAxisRequestedState_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_odrive_axis_requested_state_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_odrive_axis_requested_state_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_axis_requested_state_axis1_odrive_axis_requested_state_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getEncoderEstimates_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderEstimates_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_pos_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_pos_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_pos_estimate_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_vel_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_vel_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_estimates_axis1_odrive_encoder_vel_estimate_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getEncoderCount_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_count_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_encoder_count_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getEncoderCount_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_encoder_count_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_encoder_count_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_shadow_count_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_shadow_count_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_shadow_count_is_in_range(
    int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_countin_cpr_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_countin_cpr_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_encoder_count_axis1_odrive_encoder_countin_cpr_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_setControllerModes_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_controller_modes_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_controller_modes_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setControllerModes_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_controller_modes_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_controller_modes_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_control_mode_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_control_mode_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_control_mode_is_in_range(
    int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_input_mode_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_input_mode_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_controller_modes_axis1_odrive_input_mode_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_SetInputPos_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_pos_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_pos_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_SetInputPos_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_pos_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_pos_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_input_pos_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_input_pos_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_input_pos_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_vel_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_vel_ff_decode(
    int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_vel_ff_is_in_range(
    int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_torque_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_torque_ff_decode(
    int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_pos_axis1_odrive_torque_ff_is_in_range(
    int16_t value);

/**
 * Pack message ODRIVE_setInputVel_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_vel_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_vel_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setInputVel_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_vel_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_vel_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_input_vel_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_input_vel_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_input_vel_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_torque_ff_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_torque_ff_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_vel_axis1_odrive_torque_ff_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setInputTorque_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_torque_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_input_torque_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setInputTorque_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_input_torque_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_input_torque_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_input_torque_axis1_odrive_input_torque_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_input_torque_axis1_odrive_input_torque_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_input_torque_axis1_odrive_input_torque_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setLimits_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_limits_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_limits_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setLimits_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_limits_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_limits_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_velocity_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_velocity_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_velocity_limit_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_current_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_current_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_limits_axis1_odrive_current_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_StartAnticogging_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_start_anticogging_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_start_anticogging_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_StartAnticogging_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_start_anticogging_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_start_anticogging_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_setTrajVelLimit_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajVelLimit_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_odrive_traj_vel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_odrive_traj_vel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_vel_limit_axis1_odrive_traj_vel_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setTrajAccelLimit_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajAccelLimit_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_accel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_accel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_accel_limit_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_decel_limit_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_decel_limit_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_accel_limit_axis1_odrive_traj_decel_limit_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setTrajInertia_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setTrajInertia_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_odrive_traj_inertia_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_odrive_traj_inertia_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_traj_inertia_axis1_odrive_traj_inertia_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_getIQ_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_iq_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_iq_axis1_t *src_p, size_t size);

/**
 * Unpack message ODRIVE_getIQ_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_iq_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_iq_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_setpoint_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_setpoint_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_measured_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_iq_axis1_odrive_iq_measured_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_GetSensorlessEstimates_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_t
        *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_GetSensorlessEstimates_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_pos_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_pos_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_pos_estimate_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_vel_estimate_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_vel_estimate_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_sensorless_estimates_axis1_odrive_sensorless_vel_estimate_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_RebootOdrive_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_reboot_odrive_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_reboot_odrive_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_RebootOdrive_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_reboot_odrive_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_reboot_odrive_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_getVbusVoltage_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_getVbusVoltage_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_odrive_vbus_voltage_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_odrive_vbus_voltage_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_get_vbus_voltage_axis1_odrive_vbus_voltage_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_ClearErrors_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_clear_errors_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_clear_errors_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_ClearErrors_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_clear_errors_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_clear_errors_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Pack message ODRIVE_setLinearCount_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_linear_count_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_linear_count_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setLinearCount_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_linear_count_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_linear_count_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t
uwrt_mars_rover_can_odrive_set_linear_count_axis1_odrive_position_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_linear_count_axis1_odrive_position_decode(
    int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_linear_count_axis1_odrive_position_is_in_range(
    int32_t value);

/**
 * Pack message ODRIVE_setPositionGain_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_position_gain_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_position_gain_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setPositionGain_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_position_gain_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_position_gain_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_position_gain_axis1_odrive_pos_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_position_gain_axis1_odrive_pos_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_position_gain_axis1_odrive_pos_gain_is_in_range(
    uint32_t value);

/**
 * Pack message ODRIVE_setVelGain_axis1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_vel_gain_axis1_pack(
    uint8_t *dst_p,
    const struct uwrt_mars_rover_can_odrive_set_vel_gain_axis1_t *src_p,
    size_t size);

/**
 * Unpack message ODRIVE_setVelGain_axis1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int uwrt_mars_rover_can_odrive_set_vel_gain_axis1_unpack(
    struct uwrt_mars_rover_can_odrive_set_vel_gain_axis1_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_gain_is_in_range(
    uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t
uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_integrator_gain_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_integrator_gain_decode(
    uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool uwrt_mars_rover_can_odrive_set_vel_gain_axis1_odrive_vel_integrator_gain_is_in_range(
    uint32_t value);

#ifdef __cplusplus
}
#endif

#endif
